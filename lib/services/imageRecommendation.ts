/**
 * Image recommendation service for menu items
 * Provides AI-generated image suggestions using Google Gemini
 */

export interface ImageSuggestion {
  url: string;
  alt: string;
  source: "ai-generated";
  attribution?: string;
  prompt?: string; // Store the prompt used for AI generation
}

export interface ImageRateInfo {
  limit: number;
  count: number;
  remaining: number;
  reset?: string; // ISO string for next reset
}

export let lastImageGenerationRateInfo: ImageRateInfo | null = null;

export interface ImageRecommendationOptions {
  maxResults?: number;
  useAI?: boolean; // Whether to use AI generation
  style?:
    | "realistic"
    | "artistic"
    | "minimalist"
    | "professional"
    | "casual"
    | "rustic"
    | "simple"; // extra softer styles for less glossy results
}

/**
 * Generate a detailed prompt for AI image generation
 */
function generateImagePrompt(
  dishName: string,
  description?: string,
  styleOverride?: string
): string {
  // Build a richer base including sensory adjectives extracted heuristically
  const trimmedDesc = description?.trim();
  const basePrompt = trimmedDesc ? `${dishName} ‚Äì ${trimmedDesc}` : dishName;

  const stylePrompts = {
    realistic:
      "photorealistic, high-quality food photography, natural lighting, appetizing presentation",
    artistic:
      "artistic food styling, creative plating, vibrant colors, professional food photography",
    minimalist:
      "clean, minimalist food photography, simple background, elegant presentation",
    professional:
      "professional restaurant-quality food photography, beautiful plating, appetizing, high resolution",
    casual:
      "casual everyday presentation, natural diffused daylight, approachable, lightly styled, slight imperfections",
    rustic:
      "rustic homestyle presentation, wooden surface, warm natural lighting, cozy atmosphere, authentic",
    simple:
      "simple straightforward presentation, no heavy styling, neutral background, clear focus on the dish",
  };

  const selectedStyle =
    stylePrompts[styleOverride as keyof typeof stylePrompts] ||
    stylePrompts.professional;

  // Light variability cues to avoid repetition
  const variability = [
    "soft shadows",
    "balanced composition",
    "slight overhead angle",
    "45-degree angle",
    "natural color grading",
  ];
  const picked = variability.sort(() => 0.5 - Math.random()).slice(0, 2);

  return `Food photo: ${basePrompt}. Style focus: ${selectedStyle}. Include ${picked.join(
    " and "
  )}. Square 1:1, appetizing but not overly glossy, realistic portion size, no text, no watermark.`;
}

// Utility: shorten potentially huge data URLs or very long signed URLs for logging
function logUrlPreview(url: string, max: number = 80): string {
  if (!url) return "(empty)";
  if (url.startsWith("data:image")) {
    // Show mime + size info only
    const commaIdx = url.indexOf(",");
    const header =
      commaIdx > -1 ? url.substring(0, commaIdx) : url.slice(0, 32);
    const approxLen = url.length;
    return `${header},<base64> (len=${approxLen})`;
  }
  if (url.length <= max) return url;
  return `${url.slice(0, max)}‚Ä¶ (len=${url.length})`;
}

/**
 * Generate image using Google Gemini AI
 */
async function generateAIImage(
  dishName: string,
  description?: string,
  styleOverride?: string
): Promise<ImageSuggestion | null> {
  try {
    const prompt = generateImagePrompt(dishName, description, styleOverride);

    // Call our API endpoint that handles Gemini integration
    const response = await fetch("/api/generate-image", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        prompt,
        dishName,
        description,
        style: styleOverride,
      }),
    });

    if (!response.ok) {
      throw new Error(`AI image generation failed: ${response.status}`);
    }

    const data = await response.json();

    if (data.imageUrl) {
      return {
        url: data.imageUrl,
        alt: dishName,
        source: "ai-generated" as const,
        attribution: "Generated by AI",
        prompt: prompt,
      };
    }

    return null;
  } catch (error) {
    console.error("Error generating AI image:", error);
    return null;
  }
}

/**
 * Generate multiple AI images for a dish
 */
async function generateMultipleAIImages(
  dishName: string,
  description?: string,
  maxResults: number = 3,
  style: string = "professional"
): Promise<ImageSuggestion[]> {
  console.log(
    `üñºÔ∏è  Generating up to ${maxResults} AI images for: "${dishName}" (concurrency-limited)`
  );

  const variations = [
    "professional",
    "casual",
    "rustic",
    "minimalist",
    "simple",
    "artistic",
    "realistic",
  ];

  const attempts = Math.min(maxResults, variations.length);
  const suggestions: ImageSuggestion[] = [];
  const MAX_AI_CONCURRENCY = 4; // increased from 3
  let active = 0;
  let index = 0;
  let stop = false;

  async function runNext(): Promise<void> {
    if (stop) return;
    if (suggestions.length >= maxResults) return;
    if (index >= attempts) return;
    const currentIndex = index++;
    const variantStyle = variations[currentIndex];
    active++;
    try {
      const prompt = generateImagePrompt(dishName, description, variantStyle);
      console.log(
        `üé® Launch variant ${
          currentIndex + 1
        }/${attempts} style=${variantStyle} active=${active}`
      );
      const response = await fetch("/api/generate-image", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt,
          dishName,
          description,
          style: variantStyle,
        }),
      });
      console.log(
        `üì° Variant ${currentIndex + 1} status=${
          response.status
        } active=${active}`
      );
      if (response.status === 429) {
        const limitData = await response.json().catch(() => ({}));
        if (limitData && typeof limitData.limit === "number") {
          lastImageGenerationRateInfo = {
            limit: limitData.limit,
            count: limitData.count ?? limitData.limit,
            remaining: 0,
            reset: limitData.reset,
          };
        }
        console.warn(
          `üö´ Rate limit hit on variant ${
            currentIndex + 1
          }. Stopping further requests.`
        );
        stop = true;
        return;
      }
      if (!response.ok) {
        const errorData = await response
          .json()
          .catch(() => ({ error: "Unknown error" }));
        console.error(
          `‚ùå Error variant ${currentIndex + 1} status=${response.status}`,
          errorData
        );
        return;
      }
      const data = await response.json();
      if (data && typeof data.limit === "number") {
        lastImageGenerationRateInfo = {
          limit: data.limit,
          count: data.count ?? 0,
          remaining: data.remaining ?? 0,
          reset: data.reset,
        };
      }
      if (data.imageUrl) {
        suggestions.push({
          url: data.imageUrl,
          alt: dishName,
          source: "ai-generated",
          attribution: "Generated by AI",
          prompt: data.prompt || prompt,
        });
        console.log(
          `‚úÖ Stored image ${suggestions.length}/${maxResults} (variant ${
            currentIndex + 1
          }) url=${logUrlPreview(data.imageUrl)}`
        );
      } else {
        console.warn(`‚ö†Ô∏è No imageUrl for variant ${currentIndex + 1}`);
      }
    } catch (err) {
      console.error(`üí• Variant ${currentIndex + 1} error`, err);
    } finally {
      active--;
      if (!stop && suggestions.length < maxResults) {
        // Launch next task if any left
        await runNext();
      }
    }
  }

  // Seed initial concurrency
  const starters = Math.min(MAX_AI_CONCURRENCY, attempts, maxResults);
  const launches: Promise<void>[] = [];
  for (let i = 0; i < starters; i++) {
    launches.push(runNext());
  }
  await Promise.all(launches);

  console.log(
    `üéØ Generated ${suggestions.length}/${attempts} images (requested max ${maxResults}) stop=${stop}`
  );
  return suggestions;
}

/**
 * Main function to get image recommendations for a dish
 */
export async function getImageRecommendations(
  dishName: string,
  description?: string,
  options: ImageRecommendationOptions = {}
): Promise<ImageSuggestion[]> {
  const { maxResults = 3, useAI = true, style = "professional" } = options;

  console.log(
    `üîç Getting image recommendations for: "${dishName}" (maxResults: ${maxResults}, useAI: ${useAI})`
  );

  if (!dishName.trim()) {
    console.warn("‚ö†Ô∏è  Empty dish name provided");
    return [];
  }

  try {
    if (!useAI) {
      console.warn("AI generation disabled, but no fallback images available");
      return [];
    }

    // Generate multiple AI images with different styles
    const suggestions = await generateMultipleAIImages(
      dishName,
      description,
      maxResults,
      style
    );

    console.log(
      `üìã Final recommendations: ${suggestions.length} suggestions returned`
    );
    suggestions.forEach((suggestion, index) => {
      console.log(
        `  ${index + 1}. ${logUrlPreview(suggestion.url)} (${
          suggestion.source
        })`
      );
    });

    return suggestions.slice(0, maxResults);
  } catch (error) {
    console.error("‚ùå Error getting image recommendations:", error);
    return [];
  }
}

/**
 * Get a single best image recommendation for a dish
 */
export async function getBestImageRecommendation(
  dishName: string,
  description?: string,
  options: ImageRecommendationOptions = {}
): Promise<ImageSuggestion | null> {
  const { useAI = true, style = "professional" } = options;

  if (!dishName.trim()) {
    return null;
  }

  if (!useAI) {
    console.warn("AI generation disabled, no image recommendations available");
    return null;
  }

  // Try AI generation
  const aiSuggestion = await generateAIImage(dishName, description, style);
  return aiSuggestion;
}
